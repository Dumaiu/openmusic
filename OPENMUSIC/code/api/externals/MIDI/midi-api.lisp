;;===========================================================================;OM API ;Multiplatform API for OpenMusic;Macintosh version (Digitool Macintosh Common Lisp - MCL);;Copyright (C) 2004 IRCAM-Centre Georges Pompidou, Paris, France.; ;This program is free software; you can redistribute it and/or;modify it under the terms of the GNU General Public License;as published by the Free Software Foundation; either version 2;of the License, or (at your option) any later version.;;See file LICENSE for further informations on licensing terms.;;This program is distributed in the hope that it will be useful,;but WITHOUT ANY WARRANTY; without even the implied warranty of;MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the;GNU General Public License for more details.;;You should have received a copy of the GNU General Public License;along with this program; if not, write to the Free Software;Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.;;Authors: Jean Bresson and Augusto Agon;;===========================================================================;;===========================================================================; DocFile; MIDI functions called by OpenMusic; Use MIDISHARE ;;===========================================================================(in-package :oa);;;==============================;;; LOAD FRAMEWORK - INIT/EXIT MIDI;;;==============================;; renvoie t ou nil en fonction;; du chargement(defun om-midi-startup ()   (setf midishare::*midishare* nil)  (setf midishare::*player-framework* nil)  #+win32(setf cl-user::*libmidishare* (om-lib-pathname cl-user::*libmidishare*))  (ms::midishare-framework)  (when midishare::*midishare*     #+win32(setf cl-user::*libplayer* (om-lib-pathname cl-user::*libplayer*))    (midishare::player-framework)    (when midishare::*player-framework*       (push :midishare *features*)))  midishare::*player-framework*)(defun om-midi-exit ()  (midishare::close-player-framework)  ;(midishare::remove-midishare-interface)  )(defmacro om-midi-get-time ()  `(midishare::MidiGetTime))(defun om-midi-open-player (name)  (let ((newplayer (ms::openplayer name)))    (midishare::MidiConnect newplayer 0 -1)    (midishare::MidiConnect  0 newplayer -1)    newplayer    ))  (defun om-midi-close-player (player)  (midishare::closeplayer player)  ;;; (supposed to call MidiClose automatically)  ); (setq *test* (ms::openplayer "test-name")); (midishare::closeplayer *test*)(defun om-midi-extend (&optional (rate 1))  (let* ((size (ms::MidiTotalSpace))         (more (round (* size rate))))    (print (format nil "Increasing MIDI space ~D => ~D" size (+ size more)))    (ms::MidiGrowSpace more)))    ;;;==============================;;; MIDI UTILS;;;==============================(defun om-midi-get-num-from-type (typestr)  (eval (read-from-string (concatenate 'string "ms::type" typestr))));=== Converts an event name symbol to MS event type format;=== eg: KeyOn --> typeKeyOn(defun om-midi-symb2mtype (sym)  (eval (intern (concatenate 'string "TYPE" (STRING sym)) :midishare)))(defun om-midi-new-event-safe (type)  (let ((event (midishare::MidiNewEv type)))    (when (or (not event) (ms::nullptrp event))      (om-midi-extend 0.5)      (setf event (midishare::MidiNewEv type)))    event))(defun om-midi-new-evt (type &key port ref chan date vals pgm pitch kpress dur ctrlchange bend param tempo bytes)  (let ((event (om-midi-new-event-safe type)))    (unless (ms::nullptrp event)      (when chan (midishare::chan event chan))                        (when port (midishare::port event port))      (when date (midishare::date event date))      (when ref (midishare::ref event ref))      (cond (vals             (if (listp vals)                 (loop for v in vals for i = 0 then (+ i 1) do                        (midishare::field event i v))               (midishare::field event 0 vals)))            (ctrlchange             (progn (midishare::ctrl event (car ctrlchange))               (midishare::val event (cadr ctrlchange))))            (bytes             (dolist (byte (if (consp bytes) bytes (list bytes)))               (midishare::midiaddfield event byte)))          (t            (when param (midishare::param event param))           (when pgm (midishare::pgm event pgm))           (when bend (midishare::bend event bend))           (when dur (midishare::dur event dur))           (when kpress (midishare::kpress event kpress))           (when pitch (midishare::pitch event pitch))           (when tempo (midishare::tempo event tempo))           )          )      event)));; (setf evt (om-midi-new-evt (om-midi-symb2mtype 'Note)));; (om-midi-evt-get evt :dur);(setq e (ms::midi-new-ev ms::typeNote));(ms::dur e);(ms::chan e)(defun om-midi-copy-evt (event)  (ms::MidiCopyEv event))(defun om-midi-send-evt (event player)  (midishare::MidiSendIm player event))(defun om-midi-new-seq ()  (midishare::midinewseq))(defun om-midi-seq-concat-evt (seq evt &optional (end t))  (when (and evt seq)    (if end        (progn          (midishare::link (midishare::lastEv seq) evt)          (midishare::lastEv seq evt))      (progn        (midishare::link evt (midishare::firstEv seq))        (midishare::firstEv seq evt)))    ))(defun om-midi-seq-add-evt (seq evt) (midishare::MidiAddSeq seq evt))(defun om-midi-free-seq (seq)  (midishare::midifreeseq seq))(defun om-midi-seq-first-evt (seq)  (let ((evt (ms::firstEv seq)))    (unless (ms::nullptrp evt) evt)))(defun om-midi-evt-get (msevent slot)  (case slot    (:type (ms::evtype msevent))    (:date (ms::date msevent))    (:ref (ms::ref msevent))    (:port (ms::port msevent))    (:chan (ms::chan msevent))    (:fields (ms::fields msevent))    (:dur (ms::dur msevent))    (:pitch (ms::pitch msevent))    (:vel (ms::vel msevent))    (:kpress (ms::kpress msevent))    (:tempo (ms::tempo msevent))    (:text (ms::text msevent))    ))(defun om-midi-get-evt-text (msevent)  (ms::text msevent));;; many ways to set the attributes of a midi event...(defun om-midi-evt-set (evt &key dur date port ref chan pgm param kpress bend tempo ctrlchange vals bytes field text)  (when dur (ms::dur evt dur))  (when date (ms::date evt date))  (when port (ms::port evt port))  (when chan (ms::chan evt chan))  (when ref (ms::ref evt ref))  (when pgm (ms::pgm evt pgm))  (when param (ms::param evt param))  (when kpress (ms::kpress evt kpress))  (when bend (ms::bend evt bend))  (when tempo (ms::tempo evt tempo))  (when text (ms::text evt text))  (when ctrlchange     (midishare::ctrl evt (car ctrlchange))    (midishare::val evt (cadr ctrlchange)))  (when bytes (dolist (byte (if (consp bytes) bytes (list bytes)))                (midishare::midiaddfield evt byte)))  (when vals    (if (listp vals)        (loop for v in vals for i = 0 then (+ i 1) do               (midishare::field evt i v))      (midishare::field evt 0 vals)))  (when field (midishare::field evt (car field) (cadr field)))  )   (defun om-midi-next-evt (evt)  (let ((evt (ms::link evt)))    (unless (ms::nullptrp evt) evt)))(defun om-midi-copy-seq (seq &optional filtertest)  (let ((event (ms::firstEv seq))        (newseq (ms::MidiNewSeq)))    (loop while (not (ms::nullptrp event)) do          (let ((newevent (ms::MidiCopyEv event)))            (unless (or (ms::nullptrp event)                         (and filtertest (cond ((equal (car filtertest) :type)                                               (= (cadr filtertest) (midishare::evtype event)))                                              (t nil))))              (ms::MidiAddSeq newseq newevent))            (setf event (ms::link event))))    newseq))(defun om-midi-save-seq-in-file (seq filename &key (fileformat 1) (timedef 0) (clicks 1000) (tracks 1))  (let ((myInfo (ms::MidiNewMidiFileInfos))        (err 0))    (ms::mf-format myInfo fileformat)    (ms::mf-timedef myInfo timedef)    (ms::mf-clicks myInfo clicks)    (ms::mf-tracks myInfo tracks)    (setf err (midishare::MidiFileSave filename seq myInfo))    (loop while (not (zerop err))          for i from 1 to 10 do          (om-midi-extend)          (setf err (midishare::MidiFileSave filename seq myInfo)))    (midishare::midifreeseq seq)    (or (zerop err)        (progn (print "ERROR saving MIDI file") nil))))(defun om-midi-load-file (pathname sequence)   (let ((myInfo (ms::MidiNewMidiFileInfos))         err tracks clicks format timedef)     (setf err (ms::MidiFileLoad pathname sequence myInfo))     (when (zerop err)       (setf tracks (ms::mf-tracks myInfo)             clicks (ms::mf-clicks myInfo)             format (ms::mf-format myInfo)             timedef (ms::mf-timedef myInfo)))     (values err sequence tracks clicks format timedef)));;;===================;;; PLAYER;;;===================(defun om-midi-set-player (player seq &optional (ticks 1000))  ;(handler-bind ((error #'(lambda (e)   ;                          (print "Error setting the player tracks...")  ;                          (om-midi-extend)  ;                          ;(print (midishare::setalltrackplayer player seq ticks))   ;                         (abort e)  ;                          )))    (midishare::setalltrackplayer player seq ticks);    ))(defun om-midi-start-player (player) (midishare::startplayer player))(defun om-midi-pause-player (player) (midishare::PausePlayer player))(defun om-midi-cont-player (player) (midishare::contplayer player))(defun om-midi-stop-player (player) (midishare::StopPlayer player))(defun om-midi-record-player (player track) (midishare::recordplayer player track))(defun om-midi-player-get-seq (player) (midishare::getAllTrackplayer player))(defun om-midi-set-loop-player (player start end)  (midishare::SetLoopStartMsPlayer player start)  (midishare::SetLoopEndMsPlayer player end)  (midishare::SetLoopPlayer player midishare::kloopon))(defun om-midi-connect (src dest)  (midishare::MidiConnect src dest 1))(defun om-midi-disconnect (src dest)  (midishare::MidiConnect src dest 0));;;===================;;; DRIVERS;;;===================(defun midi-get-drivers ()  (let ((n (ms::MidiCountDrivers)))    (loop for i = 1 then (+ i 1) while (<= i n) collect          (ms::MidiGetIndDriver i)))); (midi-get-drivers); (midi-driver-info 127)(defun midi-driver-info (ref)  (let ((di (ms::MidiNewMidiDriverInfos))        (si (ms::MidiNewMidiSlotInfos))        (in nil) (out nil) (rep nil))    (ms::MidiGetDriverInfos ref di)    (loop for k = 1 then (+ k 1) while (<= k (ms::md-slots di)) do          (let ((slotref (ms::MidiGetIndSlot ref k))                info)            (ms::MidiGetSlotInfos (ms::MidiGetIndSlot ref k) si)            (setf info (list slotref (ms::ms-name si)))          (cond ((= (ms::ms-direction si) 2) (push info out))                ((= (ms::ms-direction si) 1) (push info in))                ((= (ms::ms-direction si) 3) (push info out) (push info in)))          ))    (setf rep (list (ms::md-name di) (reverse in) (reverse out)))    (ms::MidiFreeMidiDriverInfos di)    (ms::MidiFreeMidiSlotInfos si)    rep))(defun midi-get-connections (port)  (let ((di (ms::MidiNewMidiDriverInfos))        (si (ms::MidiNewMidiSlotInfos))        (in nil) (out nil))    (loop for ref in (midi-get-drivers) do          (ms::MidiGetDriverInfos ref di)          (loop for k = 1 then (+ k 1) while (<= k (ms::md-slots di)) do                (let* ((slotref (ms::MidiGetIndSlot ref k))                       (connect (ms::MidiIsSlotConnected port slotref))                       info)                  (when (and (numberp connect) (> connect 0))                    (ms::MidiGetSlotInfos slotref si)                    (setf info (list slotref (ms::ms-name si)))                    (cond ((= (ms::ms-direction si) 2) (push info out))                          ((= (ms::ms-direction si) 1) (push info in))                          ((= (ms::ms-direction si) 3) (push info out) (push info in))                          )))                ))    (ms::MidiFreeMidiDriverInfos di)    (ms::MidiFreeMidiSlotInfos si)    (list (reverse in) (reverse out)))); (midi-get-connections 1)(defun list-of-drivers ()  (let ((n (MidiCountDrivers))        (ref nil)        (di (MidiNewMidiDriverInfos))        (si (MidiNewMidiSlotInfos)))    (print (format nil "NB DRIVERS: ~D" n))    (loop for i = 1 then (+ i 1) while (<= i n) do          (setf ref (MidiGetIndDriver i))          (print (format nil "  DRIVER ~D: ~D" i ref))          (MidiGetDriverInfos ref di)          (print (format nil "      ~A (v. ~D)" (md-name di) (md-version di)))          (print (format nil "          ~D slots: " (md-slots di)))          (loop for k = 1 then (+ k 1) while (<= k (md-slots di)) do                (MidiGetSlotInfos (MidiGetIndSlot ref k) si)                (print (format nil "             ~D: ~A (~D)" k (ms-name si) (ms-direction si)))          ))    (MidiFreeMidiDriverInfos di)    (MidiFreeMidiSlotInfos si)))(defun connect-slot (slotref port)  (ms::MidiConnectSlot port slotref 1))(defun unconnect-slot (slotref port)  (ms::MidiConnectSlot port slotref 0))