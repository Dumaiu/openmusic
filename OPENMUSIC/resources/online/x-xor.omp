;fileheader
; (5.11 :patc (om-make-point 195 29) (om-make-point 4 44) (om-make-point 543 788) "non documentation" 183)
;endfileheader
(in-package :om)(load-lib-for 'nil)(setf *om-current-persistent* (om-load-patch1 "x-xor" '((om-load-boxcomment "comment" (om-make-point 320 134) '"INPUTS:$l1?    list$l2?    list$OPTIONAL INPUTS:$test    symbol, function or Lambda-function$key     symbol, function or Lambda-function$list       other lists$OUTPUT:$returns a list with the result of the XOR operation between  l1?, l2?  and list$" "" (om-make-point 179 31) nil (om-make-color 0 0 0) (om-make-font "Arial" 10 :family nil :style 'nil :mode '(:srcor))) (om-load-boxcomment "comment" (om-make-point 358 71) '"In this example we will test only the second element of each sublist by using a patch in lambda mode.$The patch will return$? OM->((1 b) (3 a) (4 c) (7 h))$" "" (om-make-point 75 674) nil (om-make-color 0 0 0) (om-make-font "Arial" 10 :family nil :style 'nil :mode '(:srcor))) (om-load-boxcall 'abstraction "mypatch" (om-load-patch-abs1 "mypatch" '((om-load-boxcall 'lispfun "EQUAL" 'equal '((om-load-inputfun 'input-funbox "OBJECT1" "OBJECT1" nil) (om-load-inputfun 'input-funbox "OBJECT2" "OBJECT2" nil)) (om-make-point 87 195) nil nil nil nil 1) (om-load-boxcall 'lispfun "SECOND" 'second '((om-load-inputfun 'input-funbox "LIST" "LIST" nil)) (om-make-point 119 139) nil nil nil nil 1) (om-load-boxcall 'lispfun "SECOND" 'second '((om-load-inputfun 'input-funbox "LIST" "LIST" nil)) (om-make-point 56 138) nil nil nil nil 1) (om-load-boxin "input1" 1 (om-make-point 124 61) "no documentation" nil nil nil) (om-load-boxin "input" 0 (om-make-point 64 61) "no documentation" nil nil nil) (om-load-boxout "output" 0 (om-make-point 83 256) '((om-load-inputfun 'input-funbox "out" "out" nil)) nil nil)) '((2 0 0 0 nil 0) (1 0 0 1 nil 0) (3 0 1 0 nil 0) (4 0 2 0 nil 0) (0 0 5 0 nil 0)) 5.11 nil) '((om-load-inputfun 'input-funbox "no documentation" "input" nil) (om-load-inputfun 'input-funbox "no documentation" "input1" nil)) (om-make-point 319 525) nil nil "l" nil) (om-load-boxcall 'bastype "aux1" 't 'nil (om-make-point 201 539) (om-make-point 112 26) (list (list 5 'e) (list '6e) (list 7 'h) (list 8 's)) "( (5 e) (6e) (7 h) (8 s))" nil) (om-load-boxcall 'bastype "aux1" 't 'nil (om-make-point 78 511) (om-make-point 189 27) (list (list 1 'b) (list 2 'e) (list 3 'a) (list 4 'c) (list 5 'e) (list '6s)) "( (1 b) ( 2 e) (3 a ) (4 c) (5 e) (6s))" nil) (om-load-boxcall 'genfun "X-XOR" 'x-xor '((om-load-inputfun 'input-funbox "first list" "L1?" nil) (om-load-inputfun 'input-funbox "second list" "L2?" nil) (om-load-inputfun 'input-funbox "test" "TEST" 'equal)) (om-make-point 85 597) (om-make-point 339 55) nil nil nil 1) (om-load-boxcomment "comment" (om-make-point 94 38) '"will return $? OM-> (7 1 5 1)$" "" (om-make-point 279 452) nil (om-make-color 0 0 0) (om-make-font "Arial" 10 :family nil :style 'nil :mode '(:srcor))) (om-load-boxcall 'genfun "X-XOR" 'x-xor '((om-load-inputfun 'input-funbox "first list" "L1?" nil) (om-load-inputfun 'input-funbox "second list" "L2?" nil)) (om-make-point 319 392) nil nil nil nil 1) (om-load-boxcall 'bastype "aux" 't 'nil (om-make-point 334 331) (om-make-point 79 26) (list 1 2 4 5 4 2 1) "(1 2 4 5 4 2 1) " nil) (om-load-boxcall 'bastype "aux" 't 'nil (om-make-point 248 332) (om-make-point 79 26) (list 2 4 7) "( 2 4 7)" nil) (om-load-boxcomment "comment" (om-make-point 94 38) '"will return $? OM-> (1 5 1 7)$" "" (om-make-point 61 453) nil (om-make-color 0 0 0) (om-make-font "Arial" 10 :family nil :style 'nil :mode '(:srcor))) (om-load-boxcall 'bastype "aux" 't 'nil (om-make-point 117 332) (om-make-point 79 26) (list 2 4 7) "( 2 4 7)" nil) (om-load-boxcall 'bastype "aux" 't 'nil (om-make-point 31 333) (om-make-point 79 26) (list 1 2 4 5 4 2 1) "(1 2 4 5 4 2 1) " nil) (om-load-boxcall 'genfun "X-XOR" 'x-xor '((om-load-inputfun 'input-funbox "first list" "L1?" nil) (om-load-inputfun 'input-funbox "second list" "L2?" nil)) (om-make-point 98 388) nil nil nil nil 1) (om-load-boxcomment "comment" (om-make-point 407 150) '"This function compares lists for elements that are present in either one or the other list (but not in both), and then returns them as a list. If the optional <test> argument is added (remember that this module might be extended) , the lists can be compared according to any  predicate ( the default value of <test> being Ôequal). Only elements in< l1?> that return true when compared with all the elements in < l2?> (according to the predicate), are returned in the result list. If the key argument  is included (the default function is identity), its function is first evaluated using each of < l1?> elements as input, and then the lists are compared according to the test on the results of the function.  <test> and <key> may also be connected function or subpatch icons in 'lambda' mode. Additional lists can be compared using <list>.$Beware that this operation is not commutative. $" "" (om-make-point 30 179) nil (om-make-color 0 0 0) (om-make-font "Arial" 10 :family nil :style 'nil :mode '(:srcor))) (om-load-boxcomment "comment" (om-make-point 156 30) '"x-xor" "" (om-make-point 194 6) nil (om-make-color 0 0 0) (om-make-font "Arial" 14 :family nil :style '(:bold) :mode '(:srcor)))) '((4 0 5 0 nil 0) (3 0 5 1 nil 0) (2 0 5 2 nil 0) (9 0 7 0 nil 0) (8 0 7 1 nil 0) (12 0 13 0 nil 0) (11 0 13 1 nil 0)) (list (let ((newpict (make-instance 'patch-picture :name 'kernel-om3))) (setf (thepict newpict) (om-get-picture 'kernel-om3)) (setf (name newpict) 'kernel-om3) (setf (pict-pos newpict) (om-make-point 3 33)) (setf (pict-size newpict) (om-make-point 98 83)) newpict)) 5.11))

















































































































































































































